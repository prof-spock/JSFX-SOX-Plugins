desc: generic memory routines
author: Dr_TT

@init
    null = -1;

    // structure type definition: _Memory_ListElement
    _Memory_ListElement_next     = 0;
    _Memory_ListElement_previous = 1;
    _Memory_ListElement_length   = 2;
    _Memory_ListElement_SIZE = 3;

    //========================================

    function _Memory_initialize ()
        /** Initializes free block list */
        local (block firstBlock secondBlock)
    (
        firstBlock = 1;
        secondBlock = firstBlock + _Memory_ListElement_SIZE;

        block = firstBlock;
        block[_Memory_ListElement_next]     = secondBlock;
        block[_Memory_ListElement_previous] = null;
        block[_Memory_ListElement_length]   = 0;

        block = secondBlock;
        block[_Memory_ListElement_next]     = null;
        block[_Memory_ListElement_previous] = firstBlock;
        block[_Memory_ListElement_length]   = __memtop();

        _Memory_freePtr = firstBlock;
    );

    //--------------------
    //--------------------

    function ADDR (object, offset)
        /** returns the address of field within <object> with offset
            address <offset> */
    (
        object + offset
    );

    //--------------------

    function ARRAYADDR (list, i, size)
        /** Returns the address of array element within <list> with
            index <i> and element size <size> */
    (
        list + i * size
    );

    //--------------------
    //--------------------

    function Memory_allocateRaw (length)
        /** Allocates <length> cells in local heap memory */
        local(blockLength elementPtr freeBlockPtr nextFreeBlock previousPtr)
    (
        length = max(length, 0);

        // search for free block: first fit
        elementPtr  = _Memory_freePtr;

        while (
            elementPtr  = elementPtr[_Memory_ListElement_next];
            blockLength = elementPtr[_Memory_ListElement_length];
            blockLength < length + 1
        );

        // assume search has not failed: make new free block
        freeBlockPtr = elementPtr + length + 1;
        previousPtr  = elementPtr[_Memory_ListElement_previous];
        previousPtr[_Memory_ListElement_next] = freeBlockPtr;
        freeBlockPtr[_Memory_ListElement_next] =
            elementPtr[_Memory_ListElement_next];
        freeBlockPtr[_Memory_ListElement_previous] = previousPtr;
        freeBlockPtr[_Memory_ListElement_length] = blockLength - length - 1;

        // store length in block and return <ptr>
        elementPtr[0] = length;
        elementPtr += 1;
        elementPtr
    );

    //-----

    function Memory_allocate (length)
        /** Allocates <length> cells in local heap memory and set to
	        zero */
        local(result)
    (
        result = Memory_allocateRaw(length);
        memset(result, 0, length);
        result
    );

    //-----

    function Memory_allocateArray (count, elementSize)
        /** Allocates <count> array cells in local heap memory and set
            to zero */
        local(result totalCount)
    (
        totalCount = count * elementSize;
        result = Memory_allocate(totalCount);
        result
    );

    //-----

    function Memory_set (self, count, value)
        /** Sets <count> cells at <self> to <value> */
    (
        memset(self, value, count);
    );

    //-----

    function Memory_free (self)
        /** Frees cells in local heap memory at <self> */
        local(length other)
    (
        self -= 1;
        length = self[0] + 1;
        other = _Memory_freePtr[_Memory_ListElement_next];

        self + length != other ? (
            // just relink this block
            self[_Memory_ListElement_next]      = other;
            other[_Memory_ListElement_previous] = self;
        ) : (
            // merge this and the immediately following block
            length += other[_Memory_ListElement_length];
            self[_Memory_ListElement_next] = other[_Memory_ListElement_next];
            Memory_set(other, _Memory_ListElement_SIZE, 0);
        );

        self[_Memory_ListElement_previous] = _Memory_freePtr;
        self[_Memory_ListElement_length]   = length;
        _Memory_freePtr[_Memory_ListElement_next] = self;
    );

    //========================================

    _Memory_initialize();
